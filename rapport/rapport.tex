\documentclass[12pt,titlepage]{article}

\usepackage{float}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel} 
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[top=1.5cm, bottom=1.5cm, left=1.5cm, right=1.5cm]{geometry}
\usepackage{graphicx}
\usepackage{hyperref}

% Bout de code
\usepackage{listings}
\usepackage{color}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\definecolor{grey}{rgb}{0.27,0.27,0.27}

\lstset{
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  firstnumber=0,                   % start line enumeration with line 1000
  frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{mygreen},       % keyword style
  %language=C++,                    % the language of the code
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  %rulecolor=\color{white},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  literate=
  {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
  {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
  {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
  {À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
  {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
  {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
  {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
  {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
  {Ã}{{\~A}}1 {ã}{{\~a}}1 {Õ}{{\~O}}1 {õ}{{\~o}}1
  {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
  {ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
  {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
  {€}{{\euro}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1
  {»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1
}

\begin{document}

\begin{titlepage}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\center
\textsc{\LARGE
Université de Montpellier
} \\[1cm]
\begin{figure}[h]
	\begin{minipage}[c]{.46\linewidth}
		\centering
		\includegraphics[width=1\textwidth]{img/fds.png}
	\end{minipage}
	\hfill%
	\begin{minipage}[c]{.46\linewidth}
		\centering
		\includegraphics[width=1\textwidth]{img/univ-montpellier.png}
	\end{minipage}
\end{figure}

\HRule \\[0.4cm]
{ \huge \bfseries Rapport de projet NoSQL \\ Partie I - évaluation des requêtes en étoile}
\HRule \\[1.5cm]
El Houiti Chakib \\
Kezzoul Massili
\\[1cm]
\today \\ [1cm]
\end{titlepage}

\section*{Introduction}

\subsection*{Objectif du projet}

L'objectif du projet est, dans un premier temps, de développer un mini-moteur de requête en étoiles en utilisant l'approche \textit{hexastore}. Puis dans un second temps, analyser les performances de cette approche en fonction de plusieurs jeux de données. L'approche \textit{hexastore} consiste à utiliser six index pour stocker les données. Cette méthode permet d'évaluer des requêtes de façon plus efficace.

La partie d'analyse des performances sera traitée dans un futur rapport.

\subsection*{Environnement de développement}

Le projet a été développé sur notre propre environnement de travail. Nous avons choisi de ne pas utiliser l'environnement \textit{Eclipse}, car ce dernier est très lourd et peine à s'exécuter correctement sur nos machines. Afin de palier au problème des dépendances, nous avons utilisé \textit{Maven} qui est un outil de gestion et d'automatisation de production des projets logiciels \textit{Java}. Nous avons aussi utilisé le logiciel \textit{Make} dans le but de faciliter au mieux l'initialisation de l'environnement (téléchargement des dépendances), la compilation des fichiers sources, l'exécution du programme ainsi que la création du fichier \textit{jar} qui sera ensuite utilisé pour l'exécution du programme. Aussi, afin de faciliter la coopération avec mon binôme, nous avons utilisé \textit{Git} à travers le service \href{https://github.com/chakibreds/mtq_moteur_sparql}{\textit{Github}} pour la gestion du code. 

Le programme est écrit en \textit{Java}\footnote{La version de java utilisé lors du développement du projet est la version 11.0}. Le projet utilise deux bibliothèques externes :
\begin{itemize}
	\item \textit{rdf4j} pour lire les données rdf et requêtes sparql
	\item \textit{jena} qui sera utilisée pour comparaison dans la phase d’analyse des performances
\end{itemize}

\subsection*{Structure du projet}

Pour une meilleure compréhension de l'environnement du projet, voici ci-dessous différentes informations sur les différents fichiers et répertoires du projet.

\begin{description}
	\item[\textit{src/}] Répertoire contenant les fichiers sources du projet.
	\item[\textit{target/}] Répertoire contenant les fichiers générés (les \textit{.class}) durant la production ainsi que les dépendances lier au projet.
	\item[\textit{data/}] Répertoire contenant les différents jeux de données.
	\begin{description}
		\item[Jeu de données] Les \textit{fichiers.nt} contiennent les données au format \href{https://fr.wikipedia.org/wiki/Notation3}{N3}.
		\item[Requêtes] Les {fichiers.queryset} contiennent plusieurs requêtes au format \href{https://fr.wikipedia.org/wiki/SPARQL}{SPARQL}.
	\end{description}
		\item[\textit{output/}] Répertoire contenant toutes les sorties du programme.	
		\item[\textit{README.md}] Fichier expliquant la manière d'utiliser le programme (initialisation, compilation et exécution). Referez-vous à la section \textit{Utilisation} de ce dernier pour plus d'informations.
		\item[\textit{Makefile}] Fichier qui spécifient les commandes de compilation, initialisation et autres.
		\item[\textit{pom.xml}] Fichier qui contient les informations nécessaires à Maven pour traiter le projet (nom du projet, dépendances vers d'autres projets, bibliothèques nécessaires à la compilation, etc.).
\end{description}

\section{Modèlisations et implémentation}

\subsection{Chargement des données}

\subsubsection{Jeu de données}

La première étape consiste à charger les données en mémoire vive. Les données sont dans le format \href{https://fr.wikipedia.org/wiki/Notation3}{N3}. Pour les charger, nous utilisons la méthode \textit{parseData()} de la classe principale qui, pour chaque triplet RDF du fichier, fait appel à la méthode \textit{handleStatement(Statement)} de la classe \textit{MainRDFHandler}. Cette méthode ajoute le triplet dans les six index. Le sujet, prédicat ainsi que l'objet du triplet sont quant à eux ajouté dans le dictionnaire où un entier unique est associé à chaque URI. Évidemment, les doublons sont ignorés.

\subsubsection{Dictionnaire}

Le dictionnaire associe pour chaque URI un entier unique. Cet entier est utilisé pour identifier les URI dans les index. Cela permet, d'une part, de ne pas avoir à comparer les URI en tant que chaîne de caractère. Opération qui est plus coûteuse. Mais aussi, puisque la taille d'un entier est inférieure à la taille d'une chaîne de caractère, de réduire la taille finale des index.

Concrètement, le dictionnaire est implémenté par une instance de la classe \textit{HashBiMap<String, Integer>}. La classe \textit{HashBiMap} est une classe de mapping entre deux types de données. À la différence de la classe \textit{HashMap}, la classe \textit{HashBiMap} ajoute une contrainte d'unicité sur les valeurs de ses éléments. Cette contrainte permet d'activer une \textit{vue inverse} du dictionnaire. C'est-à-dire, à partir de l'entier unique associé à une URI, on peut retrouver l'URI associée en un temps constant.

\begin{lstlisting}[language=Java]
	public static HashBiMap<String, Integer> dict = HashBiMap.create();
\end{lstlisting}

\subsubsection{Index}

Les index sont au cœur de l'approche \textit{hexastore}. Cette approche consiste à définir six index. Chaque index contient tous les triplets de la base de données suivant un certain ordre sur ces termes. Ainsi l'index suivant l'ordre \textit{Sujet > Prédicat > Objet} peut-être représenté par un tableau ou la première colonne contient les identifiants des sujet du triplet, la deuxième colonne contient les prédicats et la dernière contient les objets. Les tuples sont ordonnés d'abord sur la première colonne, puis sur la deuxième ensuite sur la dernière.

Cette approche permet de minimiser le temps de recherche de l'existence d'un tuple dans la base. Donc si on recherche un tuple où le sujet est la variable (du style : \textit{?x habite Montpellier}), alors on utilisera un des deux index qui met le sujet en dernier. Ici, on utilisera par exemple l'index suivant l'ordre \textit{Objet > Prédicat > Sujet} pour trouver les sujets qui habitent à Montpellier.


Dans notre implémentation, on a commencé par définir une classe \textit{Index} qui représente un seul index. Cette classe a comme premier attribut \textit{order}, une chaîne de caractère contenant l'ordre dans lequel sont stockés les termes de chaque triplet. Par exemple pour l'ordre \textit{Sujet > Prédicat > Objet}, l'attribut \textit{order} vaut : \textit{"spo"}. Cela nous permet de savoir dans quel type d'index on est.

L'index, à proprement parler, est définit comme une imbrication de deux instances de la classe \textit{HashMap} suivit d'une instance de la classe \textit{TreeSet}. La première instance de la classe \textit{HashMap} est un mapping entre l'identifiant du premier terme \textit{$t_1$} et une autre instance de la classe \textit{HashMap}. Cette dernière, quant à elle, est un mapping entre l'identifiant du second terme \textit{$t_2$} et une instance de la classe \textit{TreeSet}. Cette instance contient l'ensemble ordonné des derniers termes du triplet composé de $t_1$ et $t_2$.

\begin{lstlisting}[language=Java]
	private HashMap<Integer, HashMap<Integer, TreeSet<Integer>>> indexMat;
\end{lstlisting}

En utilisant cette structure, la recherche au sein d'un index se fait par un simple \textit{TreeSet indexMat.get(int, int)} qui a une complexité constante.

\subsection{Évaluation des requêtes}

Le programme prend en paramètre un fichier contenant toutes les requêtes à exécuter.
Dans cette partie, nous détaillerons la partie d'évaluation des requêtes. La lecture et l'évaluation des requêtes se font de façon parallèle. C'est-à-dire que le programme interprète une requête puis l'évalue et donne son résultat avant de passer à la suivante.

\subsubsection{Lecture}

La lecture et l'interprétation d'une requête se font par la méthode \textit{parseQuery} de la classe \textit{SPARQLParser} de la bibliothèque \textit{rdf4j}. Elle retourne un objet de la classe \textit{ParsedQuery} qui permet d'accéder à chaque pattern de la requête ainsi que ses attributs grâce à différentes méthodes qu'on ne va pas détailler ici.

Les requêtes considérées ici sont des requêtes en étoiles où la variable est toujours le sujet. Donc on a décidé de n'utiliser que l'index \textit{"pos"}.

\subsubsection{Évaluation}

Afin d'évaluer une requête, on a défini la méthode \textit{processAQuery} qui prends en paramètre une instance de la classe \textit{ParsedQuery} et se charge d'évaluer la requête. Pour cela, on parcourt les patterns (Triplets qui sont de la forme \textit{?x pred obj}) de la requête un à un et on recherche, au sein de notre index, les sujets apparaissant avec l'objet et le prédicat de ce pattern.

On réalise une intersection entre le résultat du premier pattern et le résultat du second, ainsi de suite jusqu'à la fin de la requête. Puisque nous manipulant à ce stade des ensembles ordonnés, cette intersection est faite grâce à un \textit{sort-merge-join} afin d'optimiser le temps d'évaluation finale.

\begin{lstlisting}[language=Java, caption="Sort merge join de deux listes"]
  SortedSet<Integer> merge = new TreeSet<Integer>();

  while (!listA.isEmpty() && !listB.isEmpty()) {
    if (listA.first() == listB.first()){
      merge.add(listA.first());
      listA.remove(listA.first());
      listB.remove(listB.first());
    } else if (listA.first() < listB.first()) {
      listA.remove(listA.first());
    } else {
      listB.remove(listB.first());
    }
  }
  return merge;
\end{lstlisting}

\subsection{Résultats}

Les fichiers résultant de l'exécution du programme sont mis dans le répertoire spécifié avec l'option \textit{-output}.

\paragraph{Réponses du moteur}

La sortie du programme est un fichier CSV nommé \textit{queryResult.csv}, contenant deux attributs : le numéro de la requête et les résultats de la requête sous forme d'une liste contenant l'ensemble des réponses de cette dernière.
Cette exportation est faite si l'option \textit{-export\_query\_results} est spécifié. Cette option invoque la méthode \textit{exportQueryResults()} qui permet de transformer la liste des réponses de toutes les requêtes en un fichier CSV.

Le numéro de la requête $i$ dans le fichier CSV représente la requête numéro $i$ dans le fichier des requêtes. On n'a pas exporté la requête en elle-même, car on ne stocke pas les requêtes lors de leurs évaluations. Donc on a préféré mettre le numéro dans le fichier CSV, au lieu de la requête en elle-même.

\paragraph{Temps d'exécution}

Les statistiques de notre programme sont exportées dans le fichier \textit{stats.csv} contenant les informations suivantes au format CSV : 

\begin{itemize}
  \item Nom du fichier des données.
  \item Nom du fichier contenant les requêtes.
  \item Nombre de triplets RDF
  \item Nombre de requêtes.
  \item Temps de lecture des données (ms) 
  \item Temps de lecture des requêtes (ms)
  \item Temps de création du dictionnaire (ms).
  \item Temps de création des index (ms). 
  \item Nombre d'index.
  \item Temps total d'évaluation du workload (ms). 
  \item Temps total de l'exécution du programme (ms).

\end{itemize}

\section{Conclusion}

\subsection{Utilisation du programme}

Afin de faciliter les tests de notre programme, il est exécutable via ligne de commande. Après la construction du fichier \textit{jar}, on peut exécuter notre programme avec les options suivantes : 

\begin{lstlisting}[language=Bash]
  java -jar rdfqengine.jar 
      -data "chemin/vers/fichier/données.nt" 
      -queries "chemin/vers/fichier/queries.queryset" 
      -output "chemin/vers/dossier/sortie/"
\end{lstlisting}

Notre Programme reste compilable et exécutable via le \textit{Makefile} avec \textbf{make compil} et \textbf{make run}. Les arguments sont paramètrable au sein même du \textit{Makefile}.

\textbf{NB:} N'oubliez pas d'initialiser l'environnement en exécutant le commande \textbf{make init}. 

\subsection{Perspectives}

Dans la seconde partie du projet, un travail de validation des résultats et d'évaluation des performances sera réalisé.

\end{document}